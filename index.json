[{"categories":["Java","JVM"],"content":"JVM의 핵심 구조인 런타임 데이터 영역(Runtime Data Area)을 상세히 알아봅니다. 메서드 영역, 힙, 스택, PC 레지스터, 네이티브 메서드 스택의 역할과 특징, 그리고 이를 이해해야 하는 이유까지 실전 중심으로 다룹니다.","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"이번 포스팅에서는 JVM에 대해서 그중에서도 런타임 데이터 영역을 자세히 들춰보려 한다. 이번 주제는 Java에 대해서 포스팅을 계속 해나가려면 필수적인 선행지식이라 생각이 들어 포스팅을 해나가면서 나 또한 지식을 소화해봐야겠다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:0:0","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"JVM이 뭘까? Runtime Data Area를 다루기 전에 JVM에 대한 개략적인 이해가 필요하다. JVM이란 Java Virtual Machine의 줄임말로 OS에 종속받지 않고 CPU가 JAVA를 실행할 수 있게 해주는 가상컴퓨터를 뜻한다. 해당 문장만 보면 플랫폼 독립성의 문제만 해결해주는 것 같지만 그 외에도 다양한 역할을 하는데: 위에 나온 플랫폼 독립성 확립 메모리/스레드 관리 자동화 실행 최적화 생태계 확장 (ex. Kotlin, Scala, Groovy 등) 위의 이유들 때문에 자바공화국 백엔드 시장의 표준이 되었다고 봐도 무방하다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:1:0","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"OS에 종속받지 않는다? OS에 종속받지 않는다는 것이 정확히 무슨 이야기이며 어떻게 가능한 걸까? ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:2:0","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"다른 언어들의 경우 소스 코드 → 컴파일러 → 기계어(OS/CPU 맞춤) → 실행 파일(exe, ELF 등) 위의 흐름대로 진행되며 컴파일된 실행파일이 특정 OS에 맞추어져 있다: Windows용 .exe Linux용 ELF ARM CPU용 vs. x86 CPU용도 서로 다름 위와 같기 때문에 OS + CPU 조합마다 별도로 빌드해야 하는데 ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:2:1","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"Java의 경우 소스코드 → Java Compiler → 바이트코드(.class) → JVM → 실행 위에서 핵심은 JVM이 OS/CPU 차이를 대신 처리한다는 것이다. 운영체제와 맞물리는 층이 JVM이지 Java 코드가 아니라는 것. 위의 사진과 같이 코드 작성 후에 빌드/컴파일을 하게 되면 .class 파일이 생성되는 것을 알 수 있다. 해당 .class 파일은 OS/CPU가 직접 실행할 수 있는 기계어가 아니라 **JVM이 이해하는 중간 언어(바이트코드)**이며, JVM이 이 중간 언어를 기반으로 최적화 및 기계어 변환을 수행한다. 정리하자면: 개발자: public class Hello { ... } ↓ javac: Hello.class ← 바이트코드 생성 ↓ JVM: 바이트코드 해석 + 최적화 + 기계어 변환 ↓ CPU: 실제 명령 실행 개발자가 소스코드를 빌드/컴파일하게 되면 .class 파일(바이트코드)가 생성되고, 기존의 OS/CPU 대신에 JVM이 바이트코드를 해석하고 최적화된 기계어로 바꿔 실행하는 엔진 역할을 한다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:2:2","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"JVM 전체 흐름도 JVM의 전체 흐름은 다음과 같이 이루어진다: 먼저 클래스 로더가 .class 파일을 불러와서 검증하고 초기화한 후 메모리에 적재한다 그 다음 런타임 데이터 영역이 활성화되면서 프로그램의 데이터와 상태를 관리한다 해당 공간에서는 메소드 정보, 객체, 스레드 스택 등이 저장되며 ‘저장 공간’ 역할을 한다 마지막으로 실행 엔진이 바이트코드를 해석하거나 컴파일해서 실제 CPU 명령어를 변환하고 실행한다 해당 과정에서 인터프리터나 JIT 컴파일러가 동작하며 프로그램이 ‘실행 단계’로 넘어간다 이번 포스팅에서는 런타임 데이터 영역을 알아보기 위한 것이니 대략적인 흐름만 이해하자. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:3:0","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"Runtime Data Area 런타임 데이터 영역은 위와 같이 구성되어 있는데, 총 다섯 가지 영역으로 구성된다: 메서드 영역 (Method Area) 힙 영역 (Heap Area) 스택 영역 (Stack Area) PC 레지스터 (Program Counter Register) 네이티브 메서드 스택 (Native Method Stack) ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:4:0","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"각 영역별 역할 ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:5:0","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"메서드 영역 (Method Area) JVM이 시작될 때 생성되어 클래스 로더에 의해 로드된 클래스 정보를 저장한다. 각 클래스의 바이트 코드, 상수, 필드, 메서드 등 클래스 관련 정보가 저장된다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:5:1","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"힙 영역 (Heap Area) - JVM 메모리 중 가장 큰 공간 런타임에 결정되는 참조 자료형과 new 연산자를 통해 생성된 객체 인스턴스가 힙 영역에 저장된다. 객체가 더 이상 사용되지 않으면 GC가 청소한다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:5:2","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"스택 영역 (Stack Area) 지역 변수, 매개변수, 메서드 리턴 값, 연산에 사용되는 임시 데이터가 저장되는 영역이다. 각 데이터들은 프레임 구조로 저장되며 메서드 종료 시에 삭제된다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:5:3","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"PC 레지스터 (Program Counter Register) OS의 PC 레지스터와 유사한 역할을 하지만 JVM에서 관리하는 영역으로, 스레드가 메서드를 수행할 때 멀티 스레드 환경을 보장하기 위해서 각 스레드가 실행 중인 JVM 명령의 주소를 저장/관리/추적이 가능하게 만들어준다. JVM 명령어 주소를 왜 알아야 하는데? PC 레지스터는 책갈피 역할을 한다고 봐야 하는데 스레드가 CPU를 번갈아 사용해도 돌아왔을 때 어디서부터 다시 실행해야 할지 알아야 하기 때문이다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:5:4","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"네이티브 메서드 스택 (Native Method Stack) 자바가 아닌 다른 언어(C, C++ 등)로 작성된 코드를 실행할 때 사용하는 메모리 영역이다. PC 레지스터에서는 native한(자바가 아닌 다른 언어) 명령어를 수행하면 기록 불가하기 때문에 해당 영역으로 넘어온다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:5:5","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"공유 영역 vs 개별 영역 Runtime Data Area를 효율적으로 이해하기 위해서는 “누가 이 메모리를 공유하는가?“를 기준점으로 나누어보면 좋다: 모든 스레드가 공유하는 영역 스레드별로 생성되는 영역 두 가지로 나누어볼 수 있는데: 구분 영역 이름 저장 내용 생명 주기 GC 대상 공유 영역(모든 스레드) Method Area 클래스 코드, Static 변수 JVM 시작 ~ 종료 X (거의 안 함) Heap Area 객체 인스턴스 (핵심) JVM 시작 ~ 종료 O (주요 대상) 개별 영역(스레드 당 하나) Stack 지역 변수, 메서드 흐름 스레드 시작 ~ 종료 X PC Register 현재 실행 주소 스레드 시작 ~ 종료 X Native Stack C/C++ 실행 정보 스레드 시작 ~ 종료 X 여기서 포인트는: Stack 영역이 꽉 찼을 때: StackOverflowError Heap 영역이 꽉 찼을 때: OutOfMemoryError ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:6:0","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","JVM"],"content":"이거 알면 뭐가 좋은데? 추후에 포스팅에서 다루게 되겠지만 위의 사항에 대해 정확히 알게 되면: GC 메모리 누수 스레드 OutOfMemoryError 성능 튜닝 Spring DI 컨테이너 동작 모두 Runtime Data Area와 직결되기 때문에 알아두었을 때 왜 그런 일이 발생하게 되는지에 대한 이해도가 훨씬 올라갈 수 있다. ","date":"2025-12-06","objectID":"/posts/java-jvm-runtimedataarea/:7:0","tags":["Java","JVM","메모리","성능"],"title":"JVM 시리즈 - Runtime Data Area","uri":"/posts/java-jvm-runtimedataarea/"},{"categories":["Java","객체지향"],"content":"Java 객체지향 프로그래밍의 핵심 개념인 동등성(Equality)과 동일성(Identity)의 차이를 실전 예제와 함께 알아봅니다. equals() 메서드와 == 연산자의 차이, Entity와 Value Object 구분, JPA 영속성 컨텍스트에서의 활용까지 상세히 다룹니다.","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"학습을 이어나가면서 지속적으로 듣게되는 동등성과 동일성. 대략적으로 알고있는 방향은: 동일성은 메모리 주소값이 같다 동등성은 변수가 참조하고 있는 객체의 주소가 다르더라도 값이 같다 정도로 이해하고있다. 틀린 내용은 없지만 포스팅을 하며 완전히 소화시켜보고 싶다. 아래 내용은 **[객체지향의 사실과 오해 - 조영호]**에서 참고한 내용이다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:0:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"근본적인 차이점 동등성과 동일성의 각 특징을 고려해보면: 상태를 이용하여 구분하는지 식별자를 이용하여 구분하는지 위에 두가지가 기존의 설명보다 조금더 근본적인 대답이라는 생각이든다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:1:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"상태 위에서 말하는 상태를 이용하여 구분하는것에서 상태란 정확히 무엇을 말하는걸까? 여기서 상태는 객체의 특성을 나타내는 **“값”**으로 사용이된다. 홍길동 이라는 객체의 특성을 나타낼때: 키: 180cm 몸무게: 80kg 생일: 2000/01/01 이처럼 키와 몸무게는 각자 객체는 아니지만 홍길동 객체의 특성을 나타내는 값으로 사용이되며, 현재 홍길동 객체의 상태를 설명하여준다. 상태를 이용하기에 홍길동 객체의 과거 행동에 의한 이력을 모르더라도, 현재 홍길동 객체를 간편하게 설명가능하다. 정리하자면 객체의 프로퍼티 값의 조합을 상태라고 볼 수 있겠다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:2:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"식별자 객체는 식별가능한 경계를 가진 사물을 의미하는데, 식별이 가능하다는것은 각 객체간의 구분가능한 특징이 있다는것인데, 해당 구분가능한 특징을 식별자라고 부른다. 위의 문장이 값과 객체의 차이점을 말해준다고 볼수있는데: 객체는 식별자가 있다 값은 식별자를 가지지 않는다 ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:3:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"가변과 불변 값은 불변 상태를 가진다 객체는 가변 상태를 가진다 180이라는 값은 변경되지 않지만, 홍길동 객체의 키는 시간이 흐름에 따라 185cm가 될 수 있으며, 이는 해당 객체의 상태가 변경되는 가변 상태를 가진다고 할 수 있다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:4:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"그럼 무엇으로 구분할 수 있을까 위의 내용들에 따라 우리는 값이 같은지 객체가 같은지를 고려할때: 값은 상태를 이용하여 구분 객체는 식별자를 이용하여 구분 홍길동 객체와 김철수 객체를 예로 들때: 홍길동 키: 180cm 김철수 키: 180cm 여기서 키가 동일하다라고 규정지을 수 있지만, 홍길동과 김철수의 키가 같다고 해서 홍길동과 김철수가 같다고는 할 수 없다. 이처럼: 두 객체의 키, 몸무게, 생일 등등 특정 값을 비교할때는 상태를 이용하여 비교 → 동등성 두 개의 객체가 같은지를 비교할때는 식별자를 이용하여 비교 → 동일성 ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:5:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"그럼 이걸 왜 알아야하나 객체지향 프로그래밍을 접하면서 가장 많이 들은 이야기: 역할과 책임 각 객체의 역할을 나누며 해당 역할에 맞는 명확한 책임을 갖고있어야한다 라는 말을 많이 들었다. 위에서는 비유적 예시이고 실제 프로그래밍을 할때는 Integer, String 클래스로 정의하게 되며, 값 객체로써 모델링 하다보니 혼란스러울때가 많이 있는거 같다. 하지만 동등성과 동일성을 정확히 파악해나가면(필자는 부단히 학습중), 역할 기반의 명확한 객체 모델링이 가능해진다. Entity(식별자를 지닌 객체)와 값 객체의 차이점을 정확히 규정할 수 있다: 엔티티: 식별자를 중요히 여기며 동일성과 연관 값 객체: 값/상태를 중요히 여기며 동등성과 연관 동일성의 문제인 “부수 효과”(두 변수가 하나의 객체를 공유하고 있을 때, 한 변수를 통해 객체의 상태를 변경하면 다른 변수에도 그 영향이 전달)도 예측가능한 코드로써 방지가능한데, 동등성을 중요하게 다루는 값 객체를 설계할 때 불변성을 채택하게 되며, 여러곳에서 공유되어도 부수효과 없어져 안정성이 높아지고 코드를 예측하기 쉬워진다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:6:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"동등성과 동일성 메서드 그러면 동일성과 동등성 검사 메서드를 알아보자. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:7:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"동일성 검사: == 연산자 위에서 말했듯 동일성 검사는 값/상태가 아닌 정확히 같은 객체를 가르키는지, 즉 메모리 상에서 완전히 같은 객체를 가르키고 있는지를 검사한다. String s1 = new String(\"Being\"); String s2 = new String(\"Be\"); String s3 = s1; System.out.println(s1 == s2); // false System.out.println(s1 == s3); // true ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:7:1","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"동등성 검사: equals() 메서드 동등성 검사는 값/상태가 동일한지 비교한다. 즉 메모리 주소는 다르더라도 객체가 담고있는 **내용(필드 값)**이 같은지를 비교한다. 대부분의 경우 우리가 원하는 것은 메모리 주소 비교가 아닌 논리적 동등성의 비교이다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:7:2","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"equals()의 내부 동작 equals()는 최상위 부모인 Object 클래스에 정의되어 있으며, 기본적으로는 내부적으로 == 연산자를 사용한다(동일성 비교). 하지만 String, Integer와 같이 표준 라이브러리의 많은 클래스들이 equals() 메서드를 재정의하여 필드 값을 비교하도록 구현해둔 상태이다. 그래서 직접 만든 클래스의 객체를 값/상태를 기준으로 비교하려면 반드시 equals() 메서드를 재정의해야한다. 주의: equals()를 재정의하게될 경우 일반적으로 hashCode() 메서드도 함께 재정의 해야하는데, 이유는 HashMap, HashSet 등 해시 기반 컬렉션이 정상적으로 작동하도록 보장하기 위함이다. String s1 = new String(\"hello\"); String s2 = new String(\"hello\"); System.out.println(s1.equals(s2)); // true // 사용자 정의 클래스 MyObject o1 = new MyObject(10); MyObject o2 = new MyObject(10); System.out.println(o1.equals(o2)); // false (재정의 전) 필자는 별생각없이 사용하였는데 만약 다음과 같은경우: class MyClass { String name; public MyClass(String name) { this.name = name; } } public class Main { public static void main(String[] args) { MyClass m1 = new MyClass(\"hello\"); MyClass m2 = new MyClass(\"hello\"); System.out.println(m1.name.equals(m2.name)); // true } } 별생각없이 equals를 동등성 검사로 인지후에 진행을 하였다. 동등성 검사가 진행된것은 맞지만 m1, m2의 필드값 name이 String으로 지정이 되었기에, String 내부적으로 재정의된 equals를 사용하여 동등성 검사가 가능한 경우였다. (나만바보) ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:7:3","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"객체지향 설계에서 중요한 이유 위에는 너무 뻔하디 뻔한 예시였다. 실제 설계를 할때 혼란을 야기할 수 있는 상황을 한번 재현해보려한다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:8:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"영속성과 식별자 기반 비교 상황 설정: JPA/Hibernate 엔티티 웹 애플리케이션에서 User 객체를 데이터베이스에 저장/조회 한다고 가정 class User { private Long id; // 데이터베이스 식별자 (DB Primary Key) private String email; // 생성자 및 Getter/Setter 생략 // 해당 클래스 equals()와 hashCode()를 재정의하지 않았다 가정 } // 1. 새 사용자 생성 후 저장 (id = null 상태) User u1 = new User(\"test@example.com\"); // u1.id = null // 2. DB에 저장 후 ID 할당 (id = 1L) userRepository.save(u1); // DB 작업 후, u1.id = 1L // 3. DB에서 사용자 조회 (같은 이메일로 다시 조회) User u2 = userRepository.findByEmail(\"test@example.com\"); // u2.id = 1L 뭐가 헷갈리는데? 코드를 보았을때 u1, u2는 데이터베이스상에서 완전히 같은 사용자이니 논리적으로는 동등해야 할것만 같다. 동일성 검사 u1 == u2 결과: false 이유: u2는 DB에서 새로 조회되어 메모리에 로드된 객체여서 메모리 주소가 다름 동등성 검사(재정의x) u1.equals(u2) 결과: false 이유: User 클래스에 equals를 재정의 하지않아 기본 구현인 동일성검사가 수행된다 다음과 같은 상황에 u1, u2를 논리적으로 같다고 판단하려면 User 클래스에서 id 값을 기준으로 equals와 hashCode를 재정의 해야한다! ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:8:1","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"복합 객체의 상태 기반 비교 상황 설정: 주소를 나타내는 Address 클래스가 있다고 가정하고 주소는 필드 값들이 모두 같으면 논리적으로 같은 것으로 간주한다. class Address { private String city; private String street; public Address(String city, String street) { this.city = city; this.street = street; } // 이 클래스도 equals()와 hashCode()를 재정의x } Address a1 = new Address(\"Seoul\", \"Gangnam-ro\"); Address a2 = new Address(\"Seoul\", \"Gangnam-ro\"); // 값은 같지만 새로 생성됨 뭐가 문제? 해당 객체를 HashSet에 추가한다고 가정시: Set\u003cAddress\u003e address = new HashSet\u003c\u003e(); address.add(a1); address.add(a2); System.out.println(address.size()); // 2 기대 결과: 주소의 값이 같으므로 1개만 저장되어야함 실제 결과: 2 이유는 Address에 equals가 재정의 되지 않아서 HashSet은 내부적으로 기본 equals를 사용하여 동일성 검사가 되어 false를 반환함 컬렉션은 두 객체를 내용이 같더라도 서로 다른 객체로 간주하고 모두 저장 위에 예시가 모든 경우를 대변하지도 않고 위에서 말한 기대결과와 반대인 값을 당연시 여길수도 있다고 생각하지만, 간단한 예시가 아닌 실제 복잡한 코드속에서는 놓칠수있고 간과할수있는 부분이라 판단된다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:8:2","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"},{"categories":["Java","객체지향"],"content":"마무리 동등성과 동일성의 개념을 명확히 이해하고, 상황에 맞게 equals()와 hashCode()를 적절히 재정의하는 것이 견고한 객체지향 설계의 핵심이다. ","date":"2025-12-01","objectID":"/posts/java-equality-identity-equals-hashcode/:9:0","tags":["Java","객체지향","OOP","equals","hashCode"],"title":"Java 동등성과 동일성에 대하여","uri":"/posts/java-equality-identity-equals-hashcode/"}]